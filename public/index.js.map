{"version":3,"sources":["src/js/index.js","node_modules/rollup-plugin-node-polyfills/polyfills/global.js","node_modules/rollup-plugin-node-polyfills/polyfills/buffer-es6.js","src/js/Inode.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","index","this","global$1","window","lookup","revLookup","Arr","Uint8Array","Array","inited","init","code","i","len","length","charCodeAt","encodeChunk","uint8","start","end","tmp","num","output","push","join","fromByteArray","extraBytes","parts","maxChunkLength","len2","read","buffer","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","NaN","Infinity","Math","pow","write","value","c","rt","abs","isNaN","floor","log","LN2","toString","isArray","arr","call","Buffer","TYPED_ARRAY_SUPPORT","undefined","_kMaxLength","kMaxLength","createBuffer","that","RangeError","__proto__","prototype","arg","encodingOrOffset","Error","allocUnsafe","from","TypeError","ArrayBuffer","array","byteOffset","byteLength","fromArrayLike","fromArrayBuffer","string","encoding","isEncoding","actual","slice","fromString","obj","internalIsBuffer","checked","copy","val","type","data","fromObject","assertSize","size","b","_isBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","bidirectionalIndexOf","dir","arrayIndexOf","indexOf","lastIndexOf","indexSize","arrLength","valLength","String","buf","readUInt16BE","foundIndex","found","j","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","decodeCodePointsArray","poolSize","_augment","alloc","fill","allocUnsafeSlow","isBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","arguments","equals","inspect","match","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","subarray","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","INVALID_BASE64_RE","leadSurrogate","b64","l","placeHolders","L","toByteArray","trim","replace","stringtrim","base64clean","src","dst","isFastBuffer","isSlowBuffer","constructor","require$$1","Object","freeze","INSPECT_MAX_BYTES","SlowBuffer","require$$0","Inode","id","mode","atime","mtime","ctime","Inode_2","fromBuffer","buffer$$1","toStats","Stats","FileType","DIRECTORY","FILE","Date","getSize","toBuffer","buff","update","stats","hasChanged","atimeMs","getTime","mtimeMs","ctimeMs","isFile","isDirectory","Inode_1","document","getElementById","addEventListener","getFromLocalStorage","key","localStorage","getItem","setInLocalStorage","encoder","setItem","decodeFileMetaData","encodeFileMetaData","decodeFileData","atob","encodeFileData","btoa","rootData","console","fileKeyList","JSON","parse","getFileMetaData","getFileData","entries","fileMetaData","map","reduce","acc","k","v","[object Object]","fileData","f","trace","error"],"mappings":"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","file":"index.js","sourcesContent":["const {Inode,fromBuffer}  = require(\"./Inode\");\r\nconst Buffer = require(\"buffer\").Buffer;\r\n\r\n\r\ndocument.getElementById(\"pushData\").addEventListener('click', ()=>{\r\ntry{\r\n\r\n//Access keys from storage\r\nconst getFromLocalStorage = (key) => window.localStorage.getItem(key);\r\nconst setInLocalStorage = (key,value, encoder) => window.localStorage.setItem(key,encoder(value));\r\n\r\n//Decode and Encode Data from LocalStorage\r\nconst decodeFileMetaData = (data) => fromBuffer( Buffer.from(data,\"base64\"));\r\nconst encodeFileMetaData  = (data) => (data.toBuffer()).toString(\"base64\");\r\nconst decodeFileData = (value)=>atob(value);\r\nconst encodeFileData = (value)=>btoa(value)\r\n\r\nconst rootData = decodeFileMetaData(getFromLocalStorage('/'));\r\n\r\nconsole.log(rootData);\r\n\r\nconsole.log(encodeFileMetaData(rootData));\r\n\r\nconst fileKeyList = (JSON.parse(atob(getFromLocalStorage(rootData.id))));\r\n\r\nconsole.log(fileKeyList);\r\n\r\n//pull data\r\nconst getFileMetaData = (key)=>decodeFileMetaData(getFromLocalStorage(key)); \r\nconst getFileData = (key)=>decodeFileData(getFromLocalStorage(key));\r\n//set data\r\n\r\n\r\n\r\n//Can be cleaned up\r\n//convert to object to list\r\nconst data = Object.entries(fileKeyList)\r\n//convert Keys to Data\r\nconst newData = data.map((arr)=>( [arr[0].toString(), getFileMetaData(arr[1])]));\r\n//convert Return Object structure\r\nconst fileMetaData = newData.reduce((acc,[k,v])=>({...acc,[k]:v}),{});\r\nconsole.log(fileMetaData);\r\n\r\n//encode test\r\nlet fileData ={};\r\nfor(const key in fileMetaData){\r\n    fileData[key] = getFileData(fileMetaData[key].id);\r\n}\r\nconst f = \"l.asm\";\r\nconsole.log(fileData);\r\nfileData[f] = \r\n`COMMENT !\r\nAuthor: Stephen Charbonneau\r\nPROJECT: ASSIGNMENT 5 PART C\r\nDate: 2020-08-05\r\nCourse: COSC2406\r\nDescription: Asks a user for a number selection from 0 to 15 for an initial text and\r\n             background colour then a character which it prints on the screen in random\r\n             positions 512 times displaying every combination of text and background\r\n             colour twice\r\n\r\nPSEUDO CODE:\r\n\r\nMAIN\r\n\r\nString list //Contains a list of all colurs in a menu im not writing it here\r\nScanner input = new Scanner(System.in)\r\n\r\n//User input\r\nPRINT(list)\r\nPRINT(\"Please select a text colour\")\r\nint textNum = input.nextInt()\r\nPRINT(\"Please select a background colour\")\r\nint backgroundNum = input.nextInt()\r\n//Get character to print\r\nPRINT(\"Please input a char to print\")\r\nint backgroundNum = input.nextChar()\r\n\r\n//Set initial text and background colours\r\nSetTextColor(backgroundNum*16+textNum)\r\n\r\n//get all combinations of text and backgroundcolour\r\n//ignore invalid scope im lazy\r\nfor(int i =0;i<16;i++){\r\n   for(int j=0;j<16;j++){\r\n      int[] colorCombo = (j*16)+i\r\n   }\r\n}\r\n\r\n//get max number of x and y\r\n//assume index = 0 is x and index = 1 is y\r\nint[] maxNumConsoleRows = getMaxXY()\r\n\r\n//Loop 2 times outer loop 2*256 = 512\r\nint ecx = 2\r\ndo{\r\n   //save ecx on stack\r\n   push ecx\r\n   int i = 0 //Restores counter after every loop\r\n   //print character in random positons with every colour and background colour\r\n   do{\r\n   //set terminal curser to random position in terminal to write\r\n   gotoXY(BetterRandomRange(0,maxNumConsoleRows[0]),\r\n          BetterRandomRange(0,maxNumConsoleRows[1]))\r\n   \r\n   //Set colours and increment text colour combo\r\n   SetTextColor(colorCombo[i++])\r\n\r\n   }while(--ecx)\r\n\r\n   //restore ecx outer counter\r\n   pop ecx\r\n}while(--ecx)\r\n\r\nEND MAIN\r\n\r\n!\r\nINCLUDE C:/irvine/Irvine32.inc\r\n.data                          ;data decleration\r\n\r\ntxtColor  DWORD ?\r\nbkgColor  DWORD ?\r\nchrToPrnt BYTE  ?\r\n\r\ncolorOpt   BYTE  \"Color Options:\",0 \r\nselCol1    BYTE  \"     red = 4           gray = 8       lightRed = 12\",0\r\nselCol2    BYTE  \"     blue = 1          magenta = 5    lightBlue = 9\",0\r\nselCol3    BYTE  \"     lightMagenta = 13 green = 2      brown = 6\",0\r\nselCol4    BYTE  \"     lightGreen = 10   yellow = 14    cyan = 3\",0\r\nselCol5    BYTE  \"     lightGray = 7     lightCyan = 11 white = 15\",0\r\n\r\ninputMsg1  BYTE  \"Please provide a number to select a text colour: \",0\r\ninputMsg2  BYTE  \"Please provide a number to select a background colour: \",0\r\ninputMsg3  BYTE  \"Please provide a single character: \",0\r\n\r\nmaxWinY    BYTE  ?\r\nmaxWinX    BYTE  ?\r\n\r\ncolorCombo DWORD 256 DUP(?) \r\n\r\n.code                          ;code decleration\r\n\r\n;-----------------------------------------\r\n;\r\n; Generates a random number between a given\r\n; Max and min value inclusive, should be called\r\n; after Randomize function call\r\n; Recieves: EAX, EBX, two 32-bit integers may \r\n;           be signed or unsigned, where \r\n;           EAX > EBX and EAX != EBX\r\n; Returns: EAX = Random Number between EAX \r\n;          and EBX\r\n;-----------------------------------------\r\nBetterRandomRange PROC USES ebx edx\r\n   pushfd                      ;Save flags \r\n\r\n   mov edx, eax                ;edx = eax\r\n   sub eax, ebx                ;eax -= ebx (Max-Min)\r\n   add eax, 1                  ;eax += 1  (Max+1-Min)\r\n   call RandomRange            ;Generate random number Random(Max-Min+1)\r\n   add eax, ebx                ;eax+=ebx Random(Max-Min+1) + Min\r\n\r\n   popfd                       ;Restore flags\r\n   ret                         ;Returns eax, restores ebx, and edx (USES)\r\n\r\nBetterRandomRange ENDP         ;End Function\r\n\r\n;-----------------------------------------\r\n;\r\n; Multiplies a number by 16 \r\n; Recieves: EAX integer value\r\n; Returns: EAX = EAX*16\r\n;-----------------------------------------\r\nMultiplyBy16 PROC   \r\n   pushfd                      ;Save flags \r\n   \r\n   add eax, eax                ;ebx+=eax=2*eax\r\n   add eax, eax                ;ebx+=eax=4*eax\r\n   add eax, eax                ;ebx+=eax=8*eax\r\n   add eax, eax                ;ebx+=eax=16*eax\r\n\r\n\r\n   popfd                       ;Restore flags\r\n   ret                         ;Returns eax*16\r\n\r\nMultiplyBy16 ENDP              ;End Function\r\n\r\n;-----------------------------------------\r\n;\r\n; Computes all combinations of 15 colours\r\n; Recieves: DWORD array offset in ESI\r\n; Returns: A filled array with 256 colour\r\n;          combinations\r\n;-----------------------------------------\r\ngetColorCombinations PROC USES esi eax ebx ecx\r\n   pushfd                      ;Save flags \r\n\r\n   mov ecx, 16                 ;Set loop to loop 16 times\r\n   xor eax, eax                ;eax=0              \r\n   xor ebx, ebx                ;ebx=0\r\n\r\nC1:                            ;Model nested for loop (eax=0 to 15)\r\n      push ecx                 ;Save ecx to restore after nested loop\r\n      push ebx                 ;Save ebx to restore after nested loop\r\n      mov ecx, 16              ;Loop 16 times in inner loop\r\n\r\nC2:                            ;Nested loop (ebx=0 to 15)\r\n         push eax              ;Save eax as it needs to be multiplied by 16\r\n         mov [esi], ebx        ;Move ebx to array\r\n         call MultiplyBy16     ;Multiply eax by 16\r\n         add [esi], eax        ;Add eax*16 to esi\r\n         pop eax               ;Restore eax\r\n         add esi, TYPE DWORD   ;Increment esi \r\n\r\n         inc ebx               ;Increment ebx so it goes from 0 to 15\r\n         loop C2               ;loop back to inner loop\r\n      pop ebx                  ;Restore ebx to 15\r\n      pop ecx                  ;Restore outer loop count ecx\r\n      inc eax                  ;increment eax\r\n      loop C1\r\n   \r\n   popfd                       ;Restore flags\r\n   ret                         ;Returns eax*16\r\n\r\ngetColorCombinations ENDP      ;End Function\r\n\r\n\r\nmain PROC                      ;main method starts\r\n\r\n                               ;Print Colour Menu\r\n   mov edx, OFFSET colorOpt    ;Write out info message\r\n   call WriteString\r\n   call CrLf\r\n                               ;Write out color menu:\r\n   mov edx, OFFSET selCol1     ;Write out colour options message\r\n   call WriteString\r\n   call CrLf\r\n   mov edx, OFFSET selCol2     ;Write out colour options message\r\n   call WriteString\r\n   call CrLf\r\n   mov edx, OFFSET selCol3     ;Write out colour options message\r\n   call WriteString\r\n   call CrLf\r\n   mov edx, OFFSET selCol4     ;Write out colour options message\r\n   call WriteString\r\n   call CrLf\r\n   mov edx, OFFSET selCol5     ;Write out colour options message\r\n   call WriteString\r\n   call CrLf\r\n   call CrLf\r\n\r\n                               ;Read in background colour value\r\n   mov edx, OFFSET inputMsg2   ;Prompt user for background colour value\r\n   call WriteString\r\n   call ReadInt                ;Get value entered by user\r\n   call MultiplyBy16\r\n   mov ebx, eax                ;Store value in eax in ebx for use later (to add to text)\r\n\r\n                               ;Read in Text colour value\r\n   mov edx, OFFSET inputMsg1   ;Prompt user for text colour value\r\n   call WriteString\r\n   call ReadInt                ;Get value entered by user\r\n   add eax, ebx                ;Add background colour*16 to text colour\r\n\r\n   call SetTextColor           ;Set text colour\r\n\r\n   \r\n                               ;Read in character value\r\n   mov edx, OFFSET inputMsg3   ;Prompt user for a character\r\n   call WriteString\r\n   call ReadChar               ;Get value entered by user\r\n   mov chrToPrnt, al           ;Store text colour value provided by user \r\n\r\n   call Randomize              ;Call randomize to seed random numbers\r\n   \r\n   call GetMaxXY\r\n   mov maxWinX, dl             ;Save max number of buffer columns in terminal\r\n   mov maxWinY, al             ;Save max number of buffer rows in terminal \r\n\r\n   mov esi, OFFSET colorCombo  ;Fill the array of 256 values with colour combos\r\n   call getColorCombinations  \r\n\r\n                                  ;Loop 256 times twice (512 loops)\r\n   mov ecx, 2                     ;loop twice to print 256 colours 2 twos\r\n\r\nL1:                               ;outer loop\r\n\r\n      push ecx                    ;Save main loop counter value\r\n      mov esi, OFFSET colorCombo  ;Reset esi to its OFFSET value\r\n                                  ;Loop 256 printing colour combinations and character\r\n\r\n      mov ecx, 256                ;set inner loop to loop 256 times\r\nL2:                               ;inner loop\r\n                                  ;Set colour combinations\r\n         mov eax, [esi]   \r\n         call SetTextColor        ;Set text colour\r\n         add esi, TYPE DWORD      ;increment esi to print colours\r\n         \r\n                                  ;Print character at random location\r\n                                  ;Generate random location Y to print\r\n         movzx eax, maxWinY       ;Fn parameters: Set max to rows\r\n         mov ebx, 0               ;Fn parameters: Set min to 0\r\n         Call BetterRandomRange   ;Generate random Y location     \r\n         mov dh, al                ;Save random Y location edx\r\n\r\n                                  ;Generate random location X to print\r\n         movzx eax, maxWinX       ;Fn parameters: Set max to rows, note ebx=0\r\n         mov ebx, 0               ;Fn parameters: Set min to 0\r\n         Call BetterRandomRange   ;Generate random X location     \r\n         mov dl, al               ;Save random X location to ebx\r\n\r\n         Call gotoxy              ;Place curser in random XY location\r\n\r\n                                  ;Write character\r\n         mov al, chrToPrnt        ;Print char \r\n         call WriteChar\r\n         \r\n         mov eax, 200             ;Pause for 1/5th of a second each loop\r\n         call Delay               ;Run delay\r\n\r\n         loop L2\r\n\r\n      pop ecx                    ;Restore main loop counter value\r\n\r\n      loop L1                    ;Return to L1\r\n\r\n\r\n   exit                        ;Exit program\r\nmain ENDP\r\nEND main\r\n`\r\n\r\n\r\n\r\n\r\n\r\n\r\n//\"FFFFFFFFFFFFFFF\"+fileData[\"l.txt\"];\r\n\r\n\r\n\r\nconsole.log(fileData);\r\nfileMetaData[f].size = fileData[f].length;\r\nconsole.log(fileMetaData);\r\n\r\n//save file\r\nconsole.log(fileKeyList);\r\nsetInLocalStorage(fileMetaData[f].id, fileData[f], encodeFileData);\r\nsetInLocalStorage(fileKeyList[f], fileMetaData[f], encodeFileMetaData);\r\n\r\n}catch(e){\r\n    console.trace({error: e });\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\nfunction writeFile(FS){\r\n\r\n    console.log({ fs: FS.fileSystem(), yup: \"HELLO\" });\r\n}\r\n\r\nwriteFile(FS);\r\n\r\n*/\r\n\r\n\r\n});","export default (typeof global !== \"undefined\" ? global :\n  typeof self !== \"undefined\" ? self :\n  typeof window !== \"undefined\" ? window : {});","var lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\nfunction init () {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n}\n\nfunction toByteArray (b64) {\n  if (!inited) {\n    init();\n  }\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = (tmp >> 16) & 0xFF;\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  if (!inited) {\n    init();\n  }\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[(tmp << 4) & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n    output += lookup[tmp >> 10];\n    output += lookup[(tmp >> 4) & 0x3F];\n    output += lookup[(tmp << 2) & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('')\n}\n\nfunction read (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n}\n\nvar toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : true;\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nvar _kMaxLength = kMaxLength();\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr\n};\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n};\n\nfunction allocUnsafe (that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n};\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0;\n  }\n  return Buffer.alloc(+length)\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n};\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer\n};\n\nfunction byteLength (string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap (b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this\n};\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this\n};\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this\n};\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0;\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n};\n\nBuffer.prototype.equals = function equals (b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n};\n\nBuffer.prototype.inspect = function inspect () {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>'\n};\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset;  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1);\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n};\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n};\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed;\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n};\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return fromByteArray(buf)\n  } else {\n    return fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    );\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset]\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8)\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1]\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n};\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, true, 23, 4)\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, false, 23, 4)\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, true, 52, 8)\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, false, 52, 8)\n};\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 1] = (value >>> 8);\n    this[offset] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 3] = (value >>> 24);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n  write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n};\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n  write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    );\n  }\n\n  return len\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = internalIsBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray\n}\n\n\nfunction base64ToBytes (str) {\n  return toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i];\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n}\n\nfunction isFastBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n}\n\nexport { Buffer, INSPECT_MAX_BYTES, SlowBuffer, isBuffer, _kMaxLength as kMaxLength };\n","const Buffer = require(\"buffer\").Buffer;\r\n\r\n\t var Inode = function Inode(id, size, mode, atime, mtime, ctime) {\r\n\t    this.id = id;\r\n\t    this.size = size;\r\n\t    this.mode = mode;\r\n\t    this.atime = atime;\r\n\t    this.mtime = mtime;\r\n\t    this.ctime = ctime;\r\n    };\r\n    exports.Inode = Inode;\r\n\t/**\r\n\t * Converts the buffer into an Inode.\r\n\t */\r\n\t exports.fromBuffer =  Inode.fromBuffer = function fromBuffer (buffer$$1) {\r\n\t    if (buffer$$1 === undefined) {\r\n\t        throw new Error(\"NO\");\r\n\t    }\r\n\t    return new Inode(buffer$$1.toString('ascii', 30), buffer$$1.readUInt32LE(0), buffer$$1.readUInt16LE(4), buffer$$1.readDoubleLE(6), buffer$$1.readDoubleLE(14), buffer$$1.readDoubleLE(22));\r\n\t};\r\n\t/**\r\n\t * Handy function that converts the Inode to a Node Stats object.\r\n\t */\r\n\tInode.prototype.toStats = function toStats () {\r\n\t    return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, new Date(this.atime), new Date(this.mtime), new Date(this.ctime));\r\n\t};\r\n\t/**\r\n\t * Get the size of this Inode, in bytes.\r\n\t */\r\n\tInode.prototype.getSize = function getSize () {\r\n\t    // ASSUMPTION: ID is ASCII (1 byte per char).\r\n\t    return 30 + this.id.length;\r\n\t};\r\n\t/**\r\n\t * Writes the inode into the start of the buffer.\r\n\t */\r\n\tInode.prototype.toBuffer = function toBuffer (buff) {\r\n\t        if ( buff === void 0 ) buff = Buffer.alloc(this.getSize());\r\n\t    buff.writeUInt32LE(this.size, 0);\r\n\t    buff.writeUInt16LE(this.mode, 4);\r\n\t    buff.writeDoubleLE(this.atime, 6);\r\n\t    buff.writeDoubleLE(this.mtime, 14);\r\n\t    buff.writeDoubleLE(this.ctime, 22);\r\n\t    buff.write(this.id, 30, this.id.length, 'ascii');\r\n\t    return buff;\r\n\t};\r\n\t/**\r\n\t * Updates the Inode using information from the stats object. Used by file\r\n\t * systems at sync time, e.g.:\r\n\t * - Program opens file and gets a File object.\r\n\t * - Program mutates file. File object is responsible for maintaining\r\n\t *   metadata changes locally -- typically in a Stats object.\r\n\t * - Program closes file. File object's metadata changes are synced with the\r\n\t *   file system.\r\n\t * @return True if any changes have occurred.\r\n\t */\r\n\tInode.prototype.update = function update (stats) {\r\n\t    var hasChanged = false;\r\n\t    if (this.size !== stats.size) {\r\n\t        this.size = stats.size;\r\n\t        hasChanged = true;\r\n\t    }\r\n\t    if (this.mode !== stats.mode) {\r\n\t        this.mode = stats.mode;\r\n\t        hasChanged = true;\r\n\t    }\r\n\t    var atimeMs = stats.atime.getTime();\r\n\t    if (this.atime !== atimeMs) {\r\n\t        this.atime = atimeMs;\r\n\t        hasChanged = true;\r\n\t    }\r\n\t    var mtimeMs = stats.mtime.getTime();\r\n\t    if (this.mtime !== mtimeMs) {\r\n\t        this.mtime = mtimeMs;\r\n\t        hasChanged = true;\r\n\t    }\r\n\t    var ctimeMs = stats.ctime.getTime();\r\n\t    if (this.ctime !== ctimeMs) {\r\n\t        this.ctime = ctimeMs;\r\n\t        hasChanged = true;\r\n\t    }\r\n\t    return hasChanged;\r\n\t};\r\n\t// XXX: Copied from Stats. Should reconcile these two into something more\r\n\t//  compact.\r\n\t/**\r\n\t * @return [Boolean] True if this item is a file.\r\n\t */\r\n\tInode.prototype.isFile = function isFile () {\r\n\t    return (this.mode & 0xF000) === FileType.FILE;\r\n\t};\r\n\t/**\r\n\t * @return [Boolean] True if this item is a directory.\r\n\t */\r\n\tInode.prototype.isDirectory = function isDirectory () {\r\n\t    return (this.mode & 0xF000) === FileType.DIRECTORY;\r\n\t};"]}